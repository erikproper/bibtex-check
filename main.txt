func IsEven(Number int) bool {
	return Number%2 == 0
}

type TNamedStringsSet map[string]string

func (Set TNamedStringsSet) AddRange(Items []string) TNamedStringsSet {
	// Takes a set of strings as input.
	// This set should actually be pairs of strings and their names.
	// As such, it should always be an even range
	var s string
	var l int

	for i, Item := range Items {
		l = i

		if IsEven(i) {
			s = Item
		} else {
			Set[s] = Item
		}
	}

	// We should never have this situation ... can we throw an exception and bring down the app?
	if IsEven(l) {
		fmt.Println("ERROR: We are missing a name for a range of named strings: ")
		fmt.Println(" - Set  :", Set)
		fmt.Println(" - Items:", Items)
	}

	return Set
}


func NewNamedStringsSet(Items ...string) TNamedStringsSet {
	Set := TNamedStringsSet{}

	return Set.AddRange(Items)
}

func (Set TNamedStringsSet) Add(Items ...string) TNamedStringsSet {
	return Set.AddRange(Items)
}

-----


type TStringsSet map[string]bool

func (set TStringsSet) addRange(items []string) TStringsSet {
	for _, item := range items {
		set[item] = true
	}

	return set
}

func NewNamedStringsSet(items ...string) TStringsSet {
	set := TStringsSet{}

	return set.addRange(items)
}

func (set TStringsSet) Add(items ...string) TStringsSet {
	return set.addRange(items)
}

func (set TStringsSet) Remove(items ...string) TStringsSet {
	for _, item := range items {
		delete(set, item)
	}

	return set
}

func (set TStringsSet) Contains(items ...string) bool {
	contains := true
	containsItems := true

	for _, item := range items {
		_, contains = set[item]

		containsItems = containsItems && contains

		// We are done as soon as we come across an Item that is not contained in the set
		if !containsItems {
			return containsItems
		}
	}

	return containsItems
}